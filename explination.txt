OPERATING SYSTEMS LAB - DETAILED EXPLANATIONS

================================================================================
DEMONSTRATION 1: PROCESS DUPLICATION WITH fork() SYSTEM CALL
================================================================================

File: process_creation.c

This program illustrates how Unix-like systems create new processes through 
the fork() mechanism.

Technical Breakdown:
- fork() duplicates the calling process, creating a parent-child relationship
- Return values differ between processes:
  * Child receives 0
  * Parent receives the child's process identifier
  * Negative value indicates failure

Program Flow:
1. Invokes fork() to duplicate the current process
2. Child process (identified by return value 0) outputs its PID
3. Parent process (identified by positive return value) outputs its PID
4. Error handling for failed fork operations

This exemplifies concurrent process execution where both parent and child 
run independently after the fork point.


================================================================================
DEMONSTRATION 2: LINKER FUNCTIONALITY (Multi-File Compilation)
================================================================================

Files: file1.c and file2.c

These source files demonstrate separate compilation and the linker's role in 
creating a unified executable from multiple object files.

File Organization:

file1.c provides:
- Implementation of display_greeting() function
- Contains the actual executable code

file2.c provides:
- Forward declaration of display_greeting()
- Main entry point that invokes the external function

Compilation Process:
1. Each source file compiles independently into object code
2. Object files contain unresolved external references
3. Linker processes both object files
4. Resolves the display_greeting() reference to its implementation
5. Produces single executable with all symbols resolved

This demonstrates modular programming and separate compilation methodology.


================================================================================
DEMONSTRATION 3: LOADER OPERATION
================================================================================

File: simple_program.c

A minimal C application used to analyze dynamic library loading behavior.

Technical Details:
- Displays a simple text message
- Serves as a test case for loader analysis

Analysis Process:
1. Program prints confirmation message
2. Exits with success status

To observe loader behavior, use the ldd utility:
  $ ldd simple_program

This reveals which shared libraries are dynamically mapped into the process 
address space at runtime, demonstrating the loader's library resolution 
capabilities.


================================================================================
UNDERSTANDING THE LINKER
================================================================================

The Linker transforms compiled object files into executable programs by 
resolving interdependencies and organizing memory layout.

Core Responsibilities:

1. Symbol Resolution and Binding:
   - Maps function invocations to their implementations
   - Connects variable references across compilation units
   - Ensures all external references have corresponding definitions
   - Builds a complete symbol table for the executable

2. Address Space Organization:
   - Assigns absolute or relative memory addresses
   - Consolidates code sections from multiple object files
   - Merges data segments into unified memory regions
   - Performs address relocation for position-independent code

3. Library Integration:
   - Incorporates static libraries directly into executable
   - Records dynamic library dependencies for runtime loading
   - Resolves standard library functions (printf, malloc, etc.)
   - Handles both compile-time and load-time linking scenarios

4. Validation and Error Reporting:
   - Identifies undefined symbols (called but not implemented)
   - Detects duplicate definitions of the same symbol
   - Verifies type compatibility across compilation units
   - Reports linker errors with detailed diagnostics

Practical Context: Compiling file1.c and file2.c separately produces object 
files with unresolved references. The linker analyzes both files, locates the 
display_greeting() implementation in file1.o, and patches the call site in 
file2.o to reference the correct address.


================================================================================
UNDERSTANDING THE LOADER
================================================================================

The Loader is an operating system component that prepares executable files 
for execution by mapping them into process memory and resolving runtime 
dependencies.

Core Responsibilities:

1. Executable Loading:
   - Reads executable file format (ELF on Linux)
   - Parses program headers and sections
   - Allocates virtual memory regions for the process
   - Copies code and initialized data into memory
   - Configures memory segments (text, data, bss, stack, heap)

2. Dynamic Library Resolution:
   - Identifies shared library dependencies
   - Locates libraries in standard paths
   - Maps shared objects into process address space
   - Enables code sharing between multiple processes
   - Common libraries: libc.so (standard C), libm.so (math)

3. Runtime Address Relocation:
   - Adjusts references for actual load addresses
   - Handles Position Independent Executables (PIE)
   - Resolves Global Offset Table (GOT) entries
   - Updates Procedure Linkage Table (PLT) for dynamic calls

4. Execution Environment Setup:
   - Initializes program stack with correct alignment
   - Configures heap management structures
   - Passes command-line arguments and environment variables
   - Sets up signal handlers and thread-local storage
   - Transfers control to program entry point (_start, then main)

Practical Context: Executing ./simple_program triggers these loader actions:
- ELF executable is parsed and loaded into memory
- Required shared libraries are identified and mapped (use ldd to view)
- Runtime relocations are applied
- Stack and heap are initialized
- Control transfers to the program's main() function

The ldd command reveals loader dependencies:
- linux-vdso.so.1 - Virtual dynamic shared object (kernel interface)
- libc.so.6 - GNU C Library (standard C functions)
- ld-linux-x86-64.so.2 - Dynamic linker/loader itself
